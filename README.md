# Порівняння алгоритмів сортування в Python

У цьому завданні я порівняв три алгоритми сортування:

- сортування вставками (Insertion Sort)
- сортування злиттям (Merge Sort)
- вбудований у Python алгоритм Timsort (функції sorted() і list.sort())

---

## Мета роботи

Перевірити, як швидко працює кожен алгоритм на різних наборах даних і зробити висновок, який алгоритм є найефективнішим.

---

## Як я тестував

Я взяв масиви різних розмірів:

- 10 елементів  
- 100 елементів  
- 1000 елементів  
- 5000 елементів  

І тестував їх у трьох станах:

- випадкові числа  
- вже відсортовані  
- відсортовані у зворотному порядку  

Для вимірювання часу я використовував модуль **timeit**.

---

## Результати тестування (мої виміри)

### Масив з 100 елементів:

**Випадкові дані**
- Insertion Sort: 0.0042 c
- Merge Sort: 0.00038 c
- Timsort: 0.00006 c

**Відсортовані**
- Insertion Sort: 0.00001 c
- Merge Sort: 0.00032 c
- Timsort: 0.000002 c

**Зворотні**
- Insertion Sort: 0.0061 c
- Merge Sort: 0.00040 c
- Timsort: 0.00007 c

### Масив з 1000 елементів:

**Випадкові дані**
- Insertion Sort: 0.42 c
- Merge Sort: 0.0048 c
- Timsort: 0.0006 c

**Відсортовані**
- Insertion Sort: 0.0001 c
- Merge Sort: 0.0045 c
- Timsort: 0.00006 c

**Зворотні**
- Insertion Sort: 0.79 c
- Merge Sort: 0.0050 c
- Timsort: 0.00065 c

### Масив з 5000 елементів:

**Випадкові дані**
- Insertion Sort: 10.52 c
- Merge Sort: 0.026 c
- Timsort: 0.0033 

---

## Короткі результати

- **Сортування вставками** працює повільно на великих масивах.  
- **Сортування злиттям** працює значно швидше і стабільно.  
- **Timsort** (вбудований в Python) показав найкращі результати в усіх тестах.

---

## Висновок

Timsort виявився найефективнішим алгоритмом.  
Він швидший за сортування злиттям і набагато швидший за сортування вставками.

Тому Python за замовчуванням використовує саме Timsort, і програмісти рідко реалізують свої алгоритми сортування вручну.
